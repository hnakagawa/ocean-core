<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>Perl Ocean</title>

  <link href="css/bootstrap.min.css" rel="stylesheet">
</head>

<body>

  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <a class="brand" href="#">Perl Ocean</a>
        <div class="nav-collapse">
          <ul class="nav">
            <li>
              <a href="index.html">Home</a>
            </li>
            <li>
              <a href="installation.html">Getting Started</a>
            </li>
            <li class="active">
              <a href="#">Protocol</a>
            </li>
            <li>
              <a href="development.html">Development</a>
            </li>
            <li>
              <a href="cluster.html">Cluster</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="subnav">
      <ul class="nav nav-tabs">
        <li><a href="protocol.html">概要</a></li>
        <li><a href="protocoldatamodel.html">サービス</a></li>
        <li class="active"><a href="#">バックグラウンド</a></li>
        <li><a href="protocolscenario.html">ケーススタディ</a></li>
        <li><a href="xep.html">拡張</a></li>
      </ul>
    </div>
  </div>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3">
        <div class="well sidebar-nav">
          <ul class="nav nav-list">
            <li class="nav-header">目次</li>
            <li><a href="#data">データ紹介</a></li>
            <li><a href="#roster">ロスター</a></li>
            <li><a href="#presence">プレゼンス</a></li>
            <li><a href="#message">メッセージ</a></li>
          </ul>
        </div><!--/.well -->
      </div><!--/span-->

      <div class="span9">

        <div class="row-fluid">
          <div class="span12">
            <h2 id="background">クライアント/サーバー間のやりとり</h2>
            <p>前章では、クライアントアプリケーションのGUIのビジュアルを通して、XMPPサービスがどのようなデータを扱うサービスなのかを見てきました。ここではさらに、クライアントとサーバーの間でどのようなやり取りが行われているかを詳しく説明し、クライアントのGUIの裏で何が行われているのか、サーバーはどのようにサービスを提供しているのかを明らかにしていきます。</p>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="stream">ストリーム</h2>

            <p>XMPPでは、ログインからログアウトまでの間、一つのTCPコネクションを維持し、そのコネクション上で、前章で紹介したようなメッセージやプレゼンスをはじめとする様々なデータのやりとりを双方向に行います。このような性質から、HTTPとは違って<b>ステートフル</b>なサービスと呼ぶことが出来ます。</p>

            <div class="alert alert-block">
              <p>例えば、会員限定のWebサービスでは、ログインからログアウトまでの間のクライアントとサーバー間のやり取りは、それぞれ独立しており、Cookieなどを利用してセッションのトラッキングを行うのが一般的です。このような性質からHTTPは<b>ステートレス</b>だと言われます。</p>
            </div>

            <p>XMPPプロトコルでは、このようなコネクションの事を<b>ストリーム</b>と呼び、前章で説明したような、クライアントとサーバー間のストリームについては特に<b>C2Sストリーム</b>と呼びます。<b>C2S</b>は<b>Client to Server</b>の略語です。</p>

            <p>[図が入る]</p>

            <p>クライアントは接続完了すると、まず次のように<b>stream</b>をルートエレメントとしたXMLを送信します。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream to="xmpp.example.org" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;</pre>

            <p>サーバーはクライアントから<b>stream</b>開始タグを受信すると次のようにXMLをクライアントに向けて送信します。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream from="xmpp.example.org" id="1f6d1a" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;</pre>

            <p>接続を閉じるときは次のように<b>stream</b>の終了タグを送信しあいます。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;/stream:stream&gt;</pre>

            <span class="label label-success">server to client</span>
            <pre>&lt;/stream:stream&gt;</pre>

            <div class="alert alert-block">
              <p>実際は、上の例のように行儀よく終了タグを送らずに、いきなりTCPの切断処理をするケースも多いですが、<br/>それで特に何の問題もありません。</p>
            </div>

            <p>また、異なる事業者を利用しているユーザー間でも通信できるよう、サーバー間での通信を行うためのストリームについても定義されています。これを<b>S2Sストリーム</b>と呼び、<b>Server to Server</b>の略になります。</p>

            <p>[図が入る]</p>

            <p>このS2Sを利用すれば、例えば<b>xmpp.example.org</b>のユーザーから、<b>xmpp.example2.org</b>のユーザーに対してメッセージを送信できるわけです。SMTP(e-mail)を彷彿とさせますが、プロキシは使わず、ダイレクトにTLS接続を行い証明書を検証するなどして、サーバー間の認証をしっかり行おうということになっています。e-mailでのプロキシサーバーを踏み台としたスパム問題の鉄を踏まないように、ということですね。</p>
            <div class="alert alert-block">
              <h4 class="alert-heading">S2Sのコスト</h4>
              <p><b>Distributed</b>というのはインターネットの思想ですので、「どんな事業者間でもプロトコルにさえ従えば連携できる」、というのは素晴らしいことのように聞こえるのですが、色々な問題も出てくるのが実情です。</p>
              <p>スパムの問題に関しても、上記の対策で解決したかというと必ずしもそうではありません。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="stanza">スタンザ</h2>

            <p>当然ですが、実際は、<b>stream開始タグ</b>を送信してから、最終的に<b>stream終了タグ</b>を送信するまでの間に様々なデータが流れることになります。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream to="xmpp.example.org" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;
...
  &lt;!--メッセージの送信--&gt;
  &lt;message type='chat' to='romeo@xmpp.example.org'&gt;
    &lt;body&gt;こんにちは&lt;/body&gt;
  &lt;/message&gt;

  &lt;!--プレゼンスの変更--&gt;
  &lt;presence&gt;
    &lt;show&gt;away&lt;/show&gt;
    &lt;status&gt;買い物にでかけます。&lt;/status&gt;
  &lt;/presence&gt;
...
&lt;/stream:stream&gt;</pre>
            <p>前章でクライアントアプリケーションのGUIを通して紹介した、メッセージやプレゼンスのようなデータは、実際は裏でこのようにサーバーとやり取りされています。上記コード例の<b>message</b>や<b>presence</b>のように、ストリームの中でやりとりされる第一深度のXMLエレメントを<b>スタンザ ( stanza )</b>と呼びます。直訳すると<b>「節」</b>になります。</p>

              <p class="well">まとめると、XMPPサービスでは、クライアントとサーバー間で双方向のTCP通信を行い、そのデータはXMLで表現します。<b>stream</b>をルートエレメントとして、その下にくる第一深度のそれぞれのXMLエレメントを<b>スタンザ</b>と呼びます。<b>スタンザ</b>をイベントの単位として、クライアントとサーバーの間で<b>メッセージ送信</b>や、<b>プレゼンス変更</b>をはじめとする様々なやりとりをします。</p>
          </div>
        </div>

        <div class="row-fluid">

          <div class="span12">

            <h2 id="stanza">スタンザ受信時のサーバーの振舞い</h2>

            <p>スタンザを受け取ったときにサーバーがすべき仕事は、大きくわけると二種類です。</p>

            <h3 id="reqres">リクエスト/レスポンス型</h3>
            <p>一つは、「サーバーに対する情報のリクエストに対して、レスポンスを返すこと」で、これは例えば、「自分のロスター情報が欲しい」というリクエストに対して、適切にロスターアイテムのリストを返してあげることなどが該当します。要はWebサービスのAPIのようなものだと言えば分かりやすいかもしれません。</p>

            <p>[図が入る]</p>

            <h3 id="delivery">中継/配送</h3>
            <p>もう一つが、「メッセージやプレゼンスなどの中継、配送」です。この配送の方法は二種類あります。</p>

            <h4 id="indication">宛先指定送信</h4>

            <p>指定された特定の相手のみに対して、スタンザを配送します。一対一のチャットにおけるメッセージの送信などがこれにあたります。</p>

            <p>[図が入る]</p>

            <h4 id="broadcast">ブロードキャスト</h4>

            <p>ある条件に合致する全ての相手に対して、スタンザを配送します。例えば、プレゼンスを変更すると、自分のフォロワー全てに対して、自分のプレゼンス変更が通知されます。</p>

            <p>[図が入る]</p>

            <div class="alert alert-block">
              <p>基本的には、メッセージは<b>宛先指定送信</b>、プレゼンスは<b>ブロードキャスト</b>になります。ただし例外もあります。</p>
              <p>特定の相手にだけ別のプレゼンスを見せる<b>ダイレクトプレゼンス</b>という機能もあり、これは<b>宛先指定送信</b>になります。</p>
              <p>また、グループチャットの場合は、そのチャットルームにいるメンバー全員にメッセージが<b>ブロードキャスト</b>されます。</p>
              
            </div>

          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="stanzakinds">スタンザの種類</h2>
            <p>スタンザにはいくつか種類があります。主要なものは次の三つです。</p>
            <ul>
              <li>iq</li> 
              <li>message</li> 
              <li>presence</li> 
            </ul>
            <div class="alert alert-block">
              <p>他にもいくつか存在するのですが、上の三つ以外のものは、基本的にログイン手続きの中でしか利用しません。
              次の章<a href="protocolbackground.html">「ケーススタディ: ログインからログアウトまで」</a>を読むときに注意してみておくとよいでしょう。</p>
              <p>ログイン後は上の三つしか利用しません。</p>
            </div>
            <p>これら三つのスタンザについて詳しく説明していきますが、その前に把握しておかなければならないことが一つあります。</p>

          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="jid">JID - 宛先の特定</h2>
            <p>上で宛先指定送信の話をしましたが、宛先を特定するには何らかのIDが必要です。</p>
            <p>XMPPではユーザーのIDを表現するために<b>JID</b>というフォーマットを利用します。
            上で説明したロスターアイテムにおけるユーザーIDの表現にもJIDが使われていますし、メッセージ送信時には宛先をJIDで指定します。</p>
            <p><b>JID</b>は<b>Jabber ID</b>の略であり、プロトコル名がXMPPになる前、まだJabberだった頃の定義でそのまま残っています。</p>
            <p>具体的にどんなフォーマットなのかを確認します。次の例を見てください。</p>
            <pre>taro@xmpp.example.org</pre>
            <p>ほとんどの人が気づいたかと思いますが、e-mailアドレスとほぼ一緒ですね。ユーザーIDの後に@が続き、その後ろにサービスドメインが続きます。</p>
            <p>このようなIDを利用してメッセージの送受信を行います。まるでSMTP(e-mail)のようだと感じる人も多いでしょう。</p>

            <p>さて、JIDにはさらに次のような形態も存在します。</p>

            <pre>taro@xmpp.example.org/home</pre>
            <pre>taro@xmpp.example.org/work</pre>

            <p>上で説明したe-mailアドレスと同じようなIDの後に、<b>/ (スラッシュ)</b>が続き、さらにその後に<b>home</b>や<b>work</b>が続いているのがわかるでしょうか。この<b>home</b>や<b>work</b>のように、ドメインパートの後にスラッシュでつなげられて続く文字列を、<b>リソース</b>と呼びます。<b>リソース</b>というのは言ってしまえばコネクションIDのようなものです。</p>

            <p>とにかくtaroさんにメッセージが送りたいのなら、taro@xmpp.example.org宛にメッセージを送ります。サーバーは接続中のtaroさんの全てのコネクション、つまり、<b>taro@xmpp.example.org/home</b>と<b>taro@xmpp.example.org/work</b>の二つのコネクションに対してメッセージを配信します。</p>

            <p>taroさんの特定のコネクションに対してメッセージを送りたいのなら、<b>リソース</b>も含めたJIDを指定してメッセージを送ります。例えば <b>taro@xmpp.example.org/home</b> 宛にメッセージを送信すると、サーバーは、taroさんのすべてのコネクションにはメッセージを送らず、<b>リソース</b>がhomeになっているコネクションにだけメッセージを配信します。</p>

            <div class="alert alert-block">
              <p>これはあくまで一例です。実際はサーバーの実装次第になります。リソースを特定してメッセージを送信しても、相手の全てのコネクションにメッセージを配送するサーバーもあります。</p>
            </div>

            <p><b>リソース</b>まで含めたJIDを<b>フルJID ( Full JID )</b>、そうでないものを<b>ベアJID ( Bare JID )</b>と呼びます</p>

            <p class="well">現在はJIDの仕様がひとつのRFCで定められるようになりました。<br /> 厳密な仕様が知りたい場合は<a href="http://xmpp.org/rfcs/rfc6122.html">RFC6122</a>を確認するとよいでしょう。</p>

            <div class="alert alert-block">
              <h4 class="alert-heading">セマンティックリソースについて</h4>
              <p>上記の例では、<b>home</b>、<b>work</b>など、セマンティックなリソースを使いました。つまり、そのコネクションが自宅からのものであるとか職場からのものであるとかを推測することができるような文字列を利用したわけです。</p>
              <p>ところが実際メッセンジャークライアントでは、このようなセマンティックなリソースが有意義に使われている例はほとんどありません。</p>

              <p>[図が入る]</p>

              <p>上の画像のように、クライアントアプリケーションで、コネクション情報を集約してしまうのがよくあるパターンで、一つ一つのコネクション情報を分類して表示することはあまりありません。</p>
              <p>エンドユーザーからしたら、<b>「友人のコネクションがふたつある」</b>とか<b>「そのうちのひとつがhomeで、もうひとつがwork」</b>であるとかはどうでもいい情報で、一番大事なのは<b>「友人がオンラインでチャット可能か、メッセージが届くかどうか」</b>ということであり、クライアントアプリケーションのUIもそのように最適化がされてきたというわけです。</p>

              <p>そういう現状を鑑みるに、リソースがセマンティックである必要はなく、コネクションの識別子としてコンピュータが判断できればそれでいいわけです。ハッシュ関数などを利用してランダムな文字列を生成してしまえばよいでしょう。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="iq">iqスタンザ</h2>
            <p>IQは<b>Information Query</b>の略です。Queryという名の通り、上で解説したサーバーとクライアントのやりとりの種別のうち、<a href="#reqres">リクエスト/レスポンス型</a>のやりとりにおいてこのスタンザを利用します。</p>

            <p>ロスター要求を例に上げて説明しましょう。</p>

            <p>クライアントはサーバーに次のようにIQスタンザを送信します。iqには、必ず<b>id</b>属性と<b>type</b>属性を含めなければなりません。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;iq id='hu2bac18' type='get'&gt;
  &lt;query xmlns='jabber:iq:roster'/&gt;
&lt;/iq&gt;</pre>

            <p><b>id</b>の値は何でもよいです。クライアントアプリケーションが、リクエストに対するレスポンスをトラッキングするために、任意の値を生成します。</p>
            <p>リクエストする側では、<b>type</b>属性に、<b>get</b>か<b>set</b>のどちらかを利用します。HTTPの<b>GET</b>、<b>POST</b>のようなメソッドをイメージすればよいでしょう。</p>

            <p>iqの子エレメントは、何を要求するかによって変化します。</p>

            <p>サーバー側は次のようにレスポンスを返します。リクエストと同様に<b>id</b>属性と<b>type</b>属性を含んでいなければなりません。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq id='hu2bac18' to='juliet@example.com/balcony' type='result'&gt;
  &lt;query xmlns='jabber:iq:roster'&gt;
    &lt;item jid='romeo@example.net' name='Romeo' subscription='both'&gt;&lt;group&gt;Friends&lt;/group&gt;&lt;/item&gt;
    &lt;item jid='mercutio@example.com' name='Mercutio' subscription='from'/&gt;
    &lt;item jid='benvolio@example.net' name='Benvolio' subscription='both'/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</pre>

            <p>レスポンスにおいては<b>type</b>属性は、<b>result</b>か、<b>error</b>のどちらかになります。</p>

            <p><b>id</b>属性の値は、クライアントが送信したリクエストのiqスタンザにつけられていたものを、そのまま利用します。それによって、クライアントは、自分がいままでに送信したリクエストのうち、どのリクエストに対するレスポンスを受信したのかを判断できるようになります。</p>

          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="message">messageスタンザ</h2>
            <p><b>message</b>スタンザは非常に単純で、メッセージの配信のみがその役割になります。</p>
            <p>まず<b>type</b>属性を指定しなければなりません。次の種類があります。</p>
            <ul>
              <li><b>normal</b></li> 
              <li><b>chat</b></li> 
              <li><b>headline</b></li> 
              <li><b>groupchat</b></li> 
            </ul>

            <p>一般的には、IMでの一対一のチャットでは<b>chat</b>が選択されます。グループチャットでは文字通り<b>groupchat</b>が選択されます。<b>headline</b>は、「X月Y日のZ時からメンテナンスします。」というような、サーバーからの警告やお知らせに使えばよいでしょう。<b>normal</b>は、独立したメッセージで、メールのようなイメージを持てばよいかと思います。</p>

            <div class="alert alert-block">
              <p><b>type</b>属性を省略されている場合は<b>normal</b>として扱うことになっています。</p>
            </div>

            <p>ほかには、宛先を示す<b>to</b>属性や、送信元を示す<b>from</b>属性があります。</p>

            <div class="alert alert-block">
              <p>クライアントがメッセージを送信するときは、<b>from</b>をつけなくても、サーバー側が自動的に補填するようにします。むしろ、クライアントが<b>from</b>属性をつけた状態でメッセージを送信してきたとしても、詐称を防ぐために、サーバー側はそれを信じることなく、<b>from</b>属性を上書きするようにするのがよいでしょう。</p>
            </div>

            <p><b>message</b>の小要素として、次のようなものがあります。それぞれ省略可能です。</p>

            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th class="blue header">要素名</th>
                  <th class="blue header">概要</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>body</td><td>本文です。特に説明はいらないでしょう。たいていのメッセージには本文がつきますが例外もあります。<a href="xep.html">拡張ガイド</a>のチャットステートの章で説明します。</td></tr>
                <tr><td>subject</td><td>サブジェクト。e-mailでおなじみですね。</td></tr>
                <tr><td>thread</td><td>チャットの履歴などをトラッキングできるようにする目的で、クライアントが任意の値を生成します。</td></tr>
              </tbody>
            </table>

            <p>メッセージのやり取りの例を挙げてみましょう。</p>

            <p>まず、太郎さんは次郎さんと話したいと思い、次郎さん宛にメッセージを送信します。</p>

            <span class="label label-info">taro to server</span>
            <pre>&lt;message type='normal' to='jiro@xmpp.example.org'&gt;
  &lt;subject&gt;こんにちは&lt;/subject&gt;
  &lt;body&gt;チャットしましょう&lt;/body&gt;
&lt;/message&gt;</pre>

            <p>サーバーは、それを受け取ると、次郎さんの全てのコネクションに対して、メッセージを配送します。このとき、自動的に太郎さんのJIDを<b>from</b>属性に補填しておきます。この例では、次郎さんは<b>home</b>と<b>work</b>の二つのリソースで接続していることにしますので、二つのコネクションにメッセージが配送されます。</p>

            <span class="label label-success">server to jiro1</span>
            <pre>&lt;message type='normal' from='taro@xmpp.example.org/home' to='jiro@xmpp.example.org/home'&gt;
  &lt;subject&gt;こんにちは&lt;/subject&gt;
  &lt;body&gt;チャットしましょう&lt;/body&gt;
&lt;/message&gt;</pre>

            <span class="label label-success">server to jiro2</span>
            <pre>&lt;message type='normal' from='taro@xmpp.example.org/home' to='jiro@xmpp.example.org/work'&gt;
  &lt;subject&gt;こんにちは&lt;/subject&gt;
  &lt;body&gt;チャットしましょう&lt;/body&gt;
&lt;/message&gt;</pre>

            <p>次郎さんは、リソースが<b>home</b>になっているほうの接続で、チャットを開始するために返信します。この時<b>type</b>属性を<b>chat</b>にし、チャットの履歴をトラッキングできるように、クライアントアプリケーションが任意の<b>thread</b>値を加えます。</p>

            <span class="label label-info">jiro1 to server</span>
            <pre>&lt;message type='chat' to='taro@xmpp.example.org/home'&gt;
  &lt;thread&gt;12345&lt;/thread&gt;
  &lt;body&gt;おっけー&lt;/body&gt;
&lt;/message&gt;</pre>

            <p>サーバーは太郎さんにメッセージを配送します。</p>

            <span class="label label-success">server to taro</span>
            <pre>&lt;message type='chat' from='jiro@xmpp.example.org/home' to='taro@xmpp.example.org/home'&gt;
  &lt;thread&gt;12345&lt;/thread&gt;
  &lt;body&gt;おっけー&lt;/body&gt;
&lt;/message&gt;</pre>

            <p>太郎さんは、同じ<b>thread</b>値を使って次郎さんとのチャットを開始します。</p>

            <span class="label label-info">taro to server</span>
            <pre>&lt;message type='chat' to='jiro@xmpp.example.org/home'&gt;
  &lt;thread&gt;12345&lt;/thread&gt;
  &lt;body&gt;やっほー&lt;/body&gt;
&lt;/message&gt;</pre>

            <div class="alert alert-block">
              <p>上で挙げた例は、あくまで一例にしか過ぎず、どの<b>type</b>属性をどう扱うか、<b>body</b>以外のエレメントをどう扱うかは、結局のところ、クライアントアプリケーションの仕様次第です。サーバーはクライアントからクライアントへの配送を中継してあげるだけに過ぎません。XMPPのスペック上ではアバウトな分類があるだけで、厳格な細かいルールはありません。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="presence">presenceスタンザ</h2>
            <p><b>presence</b>スタンザには大きくわけて二種類の仕事があります。
            一つは、今までのプレゼンスの説明であった通りの、<b>プレゼンス変更情報のブロードキャスト</b>です。
            もう一つは、<b>サブスクリプションの制御</b>になります。前章で説明したように、Twitterでいうところの、いわゆる「フォロー」「アンフォロー」などがこれにあたり、XMPPでは、これらの処理も<b>presence</b>スタンザで行います。
            つまり、<b>presence</b>スタンザというのは、プレゼンス情報の<b>publish/subscribe</b>を行うスタンザです。</p>

            <p>他のスタンザと同じく、いくつかの<b>type</b>属性の種類がありますが、上記のように、二種類の仕事がありますので、二つに分けて分類してから説明していきます。</p>

            <h3 id="presencechange">プレゼンス情報変更に使われる種別</h3>
            <ul>
              <li><b>available</b></li> 
              <li><b>unavailable</b></li> 
            </ul>

            <p><b>presence</b>スタンザは次のような子要素を持ちます。</p>

            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th class="blue header">要素名</th>
                  <th class="blue header">概要</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>show</td><td>状態の種別。<b>chat(チャット可能)</b>, <b>away(ちょっと離席中)</b>、<b>xa(Extended Awayの略、長時間離席中)</b>、<b>dnd(Do not Disturbの略、邪魔しないで)</b>の四つがある。</td></tr>
                <tr><td>status</td><td>ユーザーが編集可能な状態を表すテキストメッセージ。Skypeなどでムードメッセージと呼ばれるもの。</td></tr>
                <tr><td>priority</td><td>優先値を表す数値。-127から128までの範囲。</td></tr>
              </tbody>
            </table>

            <div class="alert alert-block">
              <p>上であげたような子要素の全てが有効に利用されているかというとそうではありません。<br/>
              例えば<b>show</b>要素の値にしても本当に4種類も必要なのでしょうか。オフライン、オンライン(チャット可能)、オンライン(離席中)の三つだけで十分だという意見もありますし、場合によっては、オフラインかオンラインかわかれば十分だという意見もあります。</p>
              <p><b>priority</b>の値に関しても同様に、大多数のエンドユーザーがこの値を有効に利用できるかどうかは疑問が残ります。多くのユーザーは、「自分が複数のコネクションをつないでいて、こっちのコネクションの優先値を10にして、あっちのコネクションの優先値を1にして」などと意識することはほぼ無いと言えるでしょう。</p>
              <p><b>message</b>スタンザの時の話と同様に、このあたりの仕様もクライアントアプリケーション次第です。仕様がエンドユーザーにとって複雑すぎると判断したら、UI側でアレンジしてしまいましょう。サーバー側はパッシングするだけです。</p>
            </div>

            <h3 id="subscription">サブスクリプション制御に使われる種別</h3>
            <p>上で説明した通り、サブスクリプションの制御にも<b>presence</b>スタンザが使われます。この場合は<b>type</b>属性として、次のような値が使われます。</p>
            <ul>
              <li><b>subscribe</b></li> 
              <li><b>subscribed</b></li> 
              <li><b>unsubscribe</b></li> 
              <li><b>unsubscribed</b></li> 
            </ul>

            <p>サブスクリプション制御は、<b>メッセージの送信</b>や、<b>プレゼンス情報変更のブロードキャスト</b>に比べると、かなり複雑な処理になります。なぜなら、リクエストやレスポンスの配送だけでなく、サーバー、クライアントでそれぞれロスターの適切な編集や同期も必要になるからです。</p>

            <div class="alert alert-block">
              <p>Webサービスと連動する場合、「フォローをはじめとする友人リストの管理のような作業は、Webサービス上でやってもらうことを推奨し、XMPP上ではサブスクリプション機能はサポートしない」と割り切ってしまってもいいでしょう。最近のソーシャルネットワーク系のWebサービスの場合は、そういった機能を既に持っていることがほとんどです。</p>
            </div>

          </div>
        </div>


        <hr />
        <div class="row-fluid">
          <div class="span12">
            <p>次は、実際にクライアントがログインしてからログアウトするまでの間に、裏でどのような処理がなされるのか、ストリームがどのように状態変化していくのかを見ていくことにします。</p>

            <p><a href="protocolscenario.html" class="btn btn-primary btn-large">ケーススタディ: ログインからログアウトまで &raquo;</a></p>
          </div>
        </div>

    <hr />
    <footer>
      <p>&copy; Lyo Kato 2012</p>
    </footer>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>

</body>
</html>
