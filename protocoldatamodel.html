<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>Perl Ocean</title>

  <link href="css/bootstrap.min.css" rel="stylesheet">
</head>

<body>

  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <a class="brand" href="#">Perl Ocean</a>
        <div class="nav-collapse">
          <ul class="nav">
            <li>
              <a href="index.html">Home</a>
            </li>
            <li>
              <a href="installation.html">Getting Started</a>
            </li>
            <li class="active">
              <a href="#">Protocol</a>
            </li>
            <li>
              <a href="integration.html">Development</a>
            </li>
            <li>
              <a href="cluster.html">Cluster</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="subnav">
      <ul class="nav nav-tabs">
        <li><a href="protocol.html">概要</a></li>
        <li class="active"><a href="#">データモデル</a></li>
        <li><a href="protocolscenario.html">シナリオ</a></li>
        <li><a href="#">サポート</a></li>
      </ul>
    </div>
  </div>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3">
        <div class="well sidebar-nav">
          <ul class="nav nav-list">
            <li class="nav-header">目次</li>
            <li><a href="#data">データ紹介</a></li>
            <li><a href="#message">メッセージ</a></li>
            <li><a href="#presence">プレゼンス</a></li>
            <li><a href="#roster">ロスター</a></li>
          </ul>
        </div><!--/.well -->
      </div><!--/span-->

      <div class="span9">

        <div class="row-fluid">
          <div class="span12">
            <h2 id="data">どのようなデータを扱うのか</h2>
            <p>ここでは、XMPPが具体的にどのようなプロトコルなのかを紹介していきます。</p>
            <p>おそらくこの文書を読んでいる人の中で、「何らかのインスタントメッセンジャーを使ったことが一度もない」という人はいないと思いますが、インスタントメッセンジャーアプリケーションとは一体どんなものであるかをおさらいしながら、登場するデータや用語を整理していきましょう。</p>

            <p>XMPPはExtensible Messaging and Presence Protocol(拡張可能なメッセージングとプレゼンスのプロトコル)の略でした。<br/>つまり主役となるのはメッセージとプレゼンスですね。まずはその２つから見ていくことにします。</p>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="message">メッセージ</h3>
            <div class="alert alert-block">
              <h4 class="alert-heading">注意</h4>
              <p>ここでいう<b>メッセージ</b>とは、画像のイメージのとおり、いわゆる<b>チャットテキスト</b>の事になります。プロトコルによっては、いわゆるパケットやフレームのように、サーバーやクライアントのようなノード間で転送されるデータの一単位の塊のことを<b>メッセージ</b>と呼ぶことがあります。</p>
              <p>特にXMPPは、そのデータ配送の性質から、<b>AMQP</b>というプロトコルと並べて語られることがあります。<b>AMQP</b>はメッセージキューのための仕様を定めるもので、そこで言う<b>メッセージ</b>とは、<b>パケット</b>のような意味合いになり、<b>チャットテキスト</b>の意味ではありません。</p>
              <p>Oceanでサポートしているクラスタシステムでは、メッセージキューの利用を前提としています。<a href="cluster.html">クラスタガイド</a>にて詳しく解説します。</p>
              <p><b>メッセージ</b>とは、XMPPプロトコルのコンテキストにおいては<b>チャットテキスト</b>、メッセージキューなどのコンテキストにおいては<b>パケット</b>という意味合いになることを理解し、混乱しないように気をつけましょう。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="presence">プレゼンス</h3>
            <p>現在のユーザーの状態を表現するデータです。プレゼンスが存在すれば、その友人がオンラインであることがわかります。それだけでなく、現在チャット可能だとか離席中だとかを判断することもできます。</p>
            <p>また、現在の状態についてテキストメッセージで表現することができます。これを<b>ステータス</b>とXMPPでは呼びますが、別のプロトコルでは<b>ムードメッセージ</b>と呼んだりもします。</p>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="roster">ロスター</h3>
            <p><b>ロスター</b>とはいわゆる<b>名簿</b>の意味になり、要は友人情報のリストです。</p>
            <p>プロトコルによっては、登録された友人の事をバディーと呼び、そのリストはバディーリストと呼ばれたりします。単純にフレンドリストと呼ばれることもあります。</p>
            <p>XMPPでは、友人情報のリストを<b>ロスター</b>と呼び、一つ一つの友人情報を<b>ロスターアイテム</b>と呼びます。</p>

            <p>一つ一つのロスターアイテムは、<b>ユーザーID</b>、 <b>ニックネーム</b>、<b>自分との関係</b>、そのユーザーを分類する<b>グループ</b>などの情報を持っています。</p>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="jid">JID</h3>
            <p>XMPPではユーザーのIDを表現するために<b>JID</b>というフォーマットを利用します。
            上で説明したロスターアイテムにおけるユーザーIDの表現にもJIDが使われていますし、メッセージ送信時には宛先をJIDで指定します。</p>
            <p><b>JID</b>は<b>Jabber ID</b>の略であり、プロトコル名がXMPPになる前、まだJabberだった頃の定義でそのまま残っています。</p>
            <p>具体的にどんなフォーマットなのかを確認します。次の例を見てください。</p>
            <pre>taro@xmpp.example.org</pre>
            <p>ほとんどの人が気づいたかと思いますが、e-mailアドレスとほぼ一緒ですね。ユーザーIDの後に@が続き、その後ろにサービスドメインが続きます。</p>
            <p>このようなIDを利用してメッセージの送受信を行います。ほとんどe-mail(SMTP)と同じだ、と感じた人も多いでしょう。</p>

            <p>さて、JIDにはさらに次のような形態も存在します。</p>

            <pre>taro@xmpp.example.org/home</pre>
            <pre>taro@xmpp.example.org/work</pre>

            <p>上で説明したe-mailアドレスと同じようなIDの後に、<b>/(スラッシュ)</b>が続き、さらにその後にhomeやworkが続いているのがわかりますね。このhomeとかworkを<b>リソース</b>と呼びます。<b>リソース</b>というのは言ってしまえばコネクションIDのようなものです。</p>

            <p>とにかくtaroさんにメッセージが送りたいのなら、taro@xmpp.example.org宛にメッセージを送ります。サーバーは接続中のtaroさんのコネクションに対してメッセージを配信します。</p>

            <p>taroさんの特定のコネクションに対してメッセージを送りたいのなら、<b>リソース</b>も含めたJIDを指定してメッセージを送ります。例えばtaro@xmpp.example.org/home宛にメッセージを送信すると、サーバーは、taroさんのすべてのコネクションにはメッセージを送らず、<b>リソース</b>がhomeになっているコネクションにだけメッセージを配信します。</p>

            <p>(実際はサーバーの実装次第なのでこれはあくまで一例です)</p>

            <p><b>リソース</b>まで含めたJIDを<b>フルJID</b>、そうでないものを<b>ベアJID</b>と呼びます</p>

            <p class="well">現在はJIDの仕様がひとつのRFCで定められるようになりました。<br /> 厳密な仕様が知りたい場合は<a href="http://xmpp.org/rfcs/rfc6122.html">RFC6122</a>を確認するとよいでしょう。</p>

            <div class="alert alert-block">
              <h4 class="alert-heading">セマンティックリソースについて</h4>
              <p>上記の例では、<b>home</b>、<b>work</b>など、セマンティックなリソースを使いました。つまり、そのコネクションが自宅からのものであるとか職場からのものであるとかを推測することができるような文字列を利用したわけです。</p>
              <p>ところが実際メッセンジャークライアントでは、このようなセマンティックなリソースが有意義に使われている例はほとんどありません。</p>
              <p>上の画像のように、クライアントアプリケーションで、コネクション情報を集約してしまうのがよくあるパターンで、一つ一つのコネクション情報を分類して表示することはあまりありません。</p>
              <p>エンドユーザーからしたら、<b>「友人のコネクションがふたつある」</b>とか<b>「そのうちのひとつがhomeで、もうひとつがwork」</b>であるとかはどうでもいい情報で、一番大事なのは<b>「友人がオンラインでチャット可能か、メッセージが届くかどうか」</b>ということであり、クライアントアプリケーションのUIもそのように最適化がされてきたというわけです。</p>

              <p>そういう現状を鑑みるに、リソースがセマンティックである必要はなく、コネクションの識別子としてコンピュータが判断できればそれでいいわけです。ハッシュ関数などを利用してランダムな文字列を生成してしまえばよいでしょう。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="subscription">サブスクリプション</h3>
            <p>ロスタに存在する友人との関係を表すのがサブスクリプションです。日本語だと<b>購読</b>と訳されることが多いようですが、現在ならTwitterでいうところの<b>follow</b>と言ったほうがわかりやすいかもしれませんね。</p>
            <p>ロスターアイテムで相手との関係性を表すには次の種類があります。</p>
            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th class="blue header">種類</th>
                  <th class="blue header">概要</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>TO</td><td>その相手を一方的にフォローしている。そのユーザーのプレゼンスが変更されたら通知される。</td></tr>
                <tr><td>FROM</td><td>その相手から一方的にフォローされている。自分のプレゼンスが変更されたら相手に通知される。</td></tr>
                <tr><td>BOTH</td><td>お互いにフォローしあっている。それぞれのプレゼンスが変更されたら、相手に通知される。</td></tr>
                <tr><td>NONE</td><td>フォローはお互いにしてない。</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="service">サービスの形態</h2>
            <p>XMPPは、HTTPとは違い、ステートフルなサービス形態になります。</p>
            <p>例えば、HTTPで、会員限定サービスを行う場合は、ログインからログアウトまでの間の、クライアントとサーバー間のやり取りはそれぞれ独立しており、Cookieなどを利用してセッションのトラッキングを行うのが一般的です。</p>
            <p>XMPPの場合は、ログインからログアウトまでの間、一つのTCPコネクションを維持し、そのコネクション上で、上記のようなメッセージやプレゼンスをはじめとする様々なデータのやりとりを行います。</p>
            <p>XMPPプロトコルでは、このようなコネクションの事を<b>ストリーム</b>と呼び、ここで説明したような、クライアントとサーバー間のストリームについては特に<b>C2Sストリーム</b>と呼びます。<b>C2S</b>は<b>Client to Server</b>の略語です。</p>

            <p>また、異なる事業者を利用しているユーザー間でも通信できるよう、サーバー間での通信を行うためのストリームについても定義されています。これを<b>S2Sストリーム</b>と呼び、<b>Server to Server</b>の略になります。</p>
            <p>このS2Sを利用すれば、例えば<b>xmpp.example.org</b>のユーザーから、<b>xmpp.example2.org</b>のユーザーに対してメッセージを送信できるわけです。こちらもe-mail(SMTP)を彷彿とさせますが、プロキシは使わず、ダイレクトにTLS接続を行い証明書を検証するなどして、サーバー間の認証をしっかり行おうということになっています。e-mailでのプロキシサーバーを踏み台としたスパム問題の鉄を踏まないように、ということですね。</p>
            <div class="alert alert-block">
              <h4 class="alert-heading">S2Sのコスト</h4>
              <p><b>Distributed</b>というのはインターネットの思想ですので、「どんな事業者間でもプロトコルにさえ従えば連携できる」、というのは素晴らしいことのように聞こえるのですが、色々な問題も出てくるのが実情です。</p>
              <p>スパムの問題に関しても、上記の対策で解決したかというと必ずしもそうではありません。</p>
            </div>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="stanza">スタンザ</h2>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="stanza">宛先指定送信</h3>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="stanza">ブロードキャスト</h3>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h3 id="stanza">リクエスト/レスポンス</h3>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="results">まとめ</h2>
            <p>このページでは、ストリームと、その上でやりとりされるスタンザを中心に、XMPPでの主要な登場人物について解説しました。</p>
            <p>ここで説明に出てきたデータモデルが、XMPPにおける全ての登場人物ではありません。拡張仕様などを利用すると、他にも覚えなければならないことはいくつも出てきますが、今回は主要なところだけを押さえておきましょう。</p>
            <p>次は、実際にクライアントがログインしてからログアウトするまでの間に、裏でどのような処理がなされるのか、ストリームがどのように状態変化していくのかを見ていくことにします。</p>

            <p><a href="protocolscenario.html" class="btn btn-primary btn-large">シナリオ &raquo;</a></p>
          </div>
        </div>

    <hr />
    <footer>
      <p>&copy; Lyo Kato 2012</p>
    </footer>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>

</body>
</html>
