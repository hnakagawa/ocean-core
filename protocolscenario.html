<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>Perl Ocean</title>

  <link href="css/bootstrap.min.css" rel="stylesheet">
</head>

<body>

  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <a class="brand" href="#">Perl Ocean</a>
        <div class="nav-collapse">
          <ul class="nav">
            <li>
              <a href="index.html">Home</a>
            </li>
            <li>
              <a href="installation.html">Getting Started</a>
            </li>
            <li class="active">
              <a href="#">Protocol</a>
            </li>
            <li>
              <a href="integration.html">Development</a>
            </li>
            <li>
              <a href="cluster.html">Cluster</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="subnav">
      <ul class="nav nav-tabs">
        <li><a href="protocol.html">概要</a></li>
        <li><a href="protocoldatamodel.html">サービス</a></li>
        <li><a href="protocolbackground.html">バックグラウンド</a></li>
        <li class="active"><a href="#">ケーススタディ</a></li>
        <li><a href="xep.html">拡張</a></li>
      </ul>
    </div>
  </div>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3">
        <div class="well sidebar-nav">
          <ul class="nav nav-list">
            <li class="nav-header">目次</li>
            <li><a href="#streamstate">状態変化</a></li>
            <li><a href="#streamstart">ストリームの開始</a></li>
            <li><a href="#tls">TLSの開始</a></li>
            <li><a href="#sasl">SASL認証</a></li>
            <li><a href="#resource">リソースバインディング</a></li>
            <li><a href="#session">セッション確立</a></li>
            <li><a href="#roster">ロスター要求</a></li>
            <li><a href="#initialpresence">イニシャルプレゼンス</a></li>
            <li><a href="#available">有効状態</a></li>
            <li><a href="#unavailable">ログアウト</a></li>
            <li><a href="#timeout">タイムアウト</a></li>
          </ul>
        </div><!--/.well -->
      </div><!--/span-->

      <div class="span9">

        <div class="row-fluid">
          <div class="span12">
            <h2 id="casestudy">ログインからログアウトまでのケーススタディ</h2>
            <p>ここでは、実際に一つのクライアントがログイン処理を開始してから最終的にログアウトするまでに、クライアントとサーバーの間で具体的にどのようなやりとりがなされているかを紹介していきます。</p>
          </div>
        </div>

        <div class="row-fluid">
          <div class="span12">
            <h2 id="streamstate">ストリームの状態変化</h2>
            <p>前章で、クライアントはサーバーと、ストリームを通して様々なデータをやり取りすると説明しました。
            ただし、ストリームはいくつかの<b>状態</b>でもって管理されており、手続きを進めて<b>有効状態</b>になってからでないとメッセージやプレゼンスの送受信はできません。いわゆるログイン処理のような手続きを進め、それが完了すると、はじめて<b>有効状態</b>になり、サービスの様々な機能を利用できるようになるわけです。</p>

            <p>IMサービスにおける一般的なログイン処理の流れは次のような手順になります。</p>

            <ol>
              <li>ストリームの開始</li> 
              <li>TLSの開始(サーバーが要求するならば)</li> 
              <li>SASL認証</li>
              <li>リソースのバインディング</li>
              <li>セッションの確立</li>
              <li>ロスタの取得(クライアントが必要とするならば)</li>
              <li>イニシャルプレゼンスの送信</li>
            </ol>

            <p>ここでは、一つ一つのステップについて詳しく説明していくと同時に、実際にクライアントとサーバー間で送信されるXMLの例も紹介します。ただしここでは、全体の流れを把握することを優先し、細かい異常系の制御については省略し、正常系のみのやりとりを紹介します。細かな仕様については<a href="http://xmpp.org/rfcs/rfc6120.html">RFC6120</a>, <a href="http://xmpp.org/rfcs/rfc6121.html">RFC6121</a>を参照されるとよいでしょう。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="streamstart">ストリームの開始</h2>
            <p>TCP接続完了後、クライアントは次のように<b>stream</b>を開始します。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream to="xmpp.example.org" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;</pre>

            <p>サーバーはストリームに対し<b>id</b>を発行し、次のように、発行したIDや、サーバーがサポートする<b>features</b>を返します。</p>
            <span class="label label-success">server to client</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream from="xmpp.example.org" id="1f6d1a" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;
  &lt;stream:features&gt;
    &lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'&gt;
      &lt;required/&gt;
    &lt;/starttls&gt;
  &lt;/stream:features&gt;</pre>
            <p>上の例は、TLSを要求する場合です。TLSを要求する場合はこのような形で<b>stream</b>を返し、次の<a href="#tls">TLSの開始</a>に進みます。TLSを要求しない場合は、次のようにfeaturesを返し、<a href="#sasl">SASL認証</a>のステップに飛びます。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream from="xmpp.example.org" id="7de8a2" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;
  &lt;stream:features&gt;
    &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
      &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
      &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt;
      &lt;mechanism&gt;X-OAUTH2&lt;/mechanism&gt;
      &lt;mechanism&gt;PLAIN&lt;/mechanism&gt;
    &lt;/mechanisms&gt;
  &lt;/stream:features&gt;</pre>
            
            <p>TLSをサポートする場合は、必ず<a href="#sasl">SASL認証</a>の前に<a href="#tls">TLSの開始</a>を行わなくてはなりません。パスワードなどの機密情報が、暗号化された接続の上でやりとりされるようにするためです。</p>

            <div class="alert alert-block alert-info">
              <p>Oceanでは、設定ファイルのtlsセクションを記述すれば、自動的にTLSを要求し、手続きを進めます。このあたりの詳細に関しては、<a href="">コンフィギュレーションガイド</a>を参照してください。</p>
            </div>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="tls">TLSの開始</h2>
            <p>サーバーがセキュアな接続を要求する場合は、まずはTLSのネゴシエーションから始まります。</p>
            <p>例えば、HTTPでTLS(SSL)を利用する場合は、はじめにネゴシエーションを完了してからリクエストを送信しますが、XMPPの場合は、上述のようにプレーンな状態で<a href="#streamstart">ストリーム開始</a>のやり取りを行なってから、TLSネゴシエーションを開始します。</p>
            
            <div class="alert alert-block">
              <p>サーバーによっては、HTTPのように最初にTLS化してからstreamのやり取りを開始するものもありますが、正確には、仕様に沿った挙動ではありません。</p>
            </div>

            <p>まず、クライアントがTLS開始の意思をサーバーに伝えます。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre>

            <p>サーバーはproceedを返すと、TLSネゴシエーションを待ち受けます。</p>
            <span class="label label-success">server to client</span>
            <pre>&lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt;</pre>

            <p>ここでTLSの交渉を行い、成功すると、クライアントは<b>stream</b>をリフレッシュします。</p>
            
            <div class="alert alert-block">
              <p>XMLをルートエレメントから送信しなおすだけで、TCP接続自体を一度切断して接続し直すわけではありません。</p>
            </div>

            <span class="label label-info">client to server</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream to="xmpp.example.org" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;</pre>

            <p>サーバーは前回と同様にIDを発行して、<b>features</b>を含めて返します。<br />
            今回は、次の<a href="#sasl">SASL認証</a>に必要な情報を<b>features</b>に含めます。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream from="xmpp.example.org" id="7de8a2" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;
  &lt;stream:features&gt;
    &lt;mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;
      &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt;
      &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt;
      &lt;mechanism&gt;X-OAUTH2&lt;/mechanism&gt;
      &lt;mechanism&gt;PLAIN&lt;/mechanism&gt;
    &lt;/mechanisms&gt;
  &lt;/stream:features&gt;</pre>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="sasl">SASL認証</h2>
            <p>XMPPでは、<a href="http://tools.ietf.org/html/rfc2222">RFC2222</a>で定義されている<b>SASL</b>というチャレンジ/レスポンス型の認証方式を使って、ユーザーの認証を行います。</p>
            <p>大まかな手順は次のようになります</p>
            <ol>
              <li>サーバーはサポートしている認証メカニズムのリストを提示</li> 
              <li>クライアントは、提示されたものの中から認証メカニズムを選択</li>
              <li>選択した認証メカニズムの仕様に従って、認証が完了するまで、クライアントとサーバー間でチャレンジとレスポンスの応答を繰り返す</li>
            </ol>

            <p>XMPPで利用される、SASLの認証メカニズムはだいたい決まっていて、次の3つをサポートしているサーバーやクライアントが多いようです。</p>

            <ul>
              <li>PLAIN</li>
              <li>CRAM-MD5</li>
              <li>DIGEST-MD5</li>
            </ul>

            <div class="alert alert-block alert-info">
              <p>Oceanでも、この3つをサポートしています。</p>
            </div>

            <p>さらに最近では多くのWebサービスが、OAuthのような三者間の認可のメカニズムの上でAPIを提供していますが、OAuthで発行したトークンを、このSASLで使えるように、独自のメカニズムを定義しているケースも多いようです。</p>

            <p>以下のようなものが使われていたりします。</p>

            <ul>
              <li>X-FACEBOOK-PLATFORM</li> 
              <li>X-OAUTH2</li> 
              <li>X-MESSENGER-OAUTH2</li>
            </ul>

            <div class="alert alert-block alert-info">
              <p>Oceanでは、<b>X-OAUTH2</b>をサポートし、<b>PLAIN</b>認証とほぼ同じような手続で、単純にアクセストークンにをbase64エンコードしたものを渡せばよいようになっています。</p>
            </div>


            <p>ここでは、メカニズムに<b>PLAIN</b>を選択した場合の手続きの例を示すことにします。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='PLAIN'&gt;AGp1bGlldAByMG0zMG15cjBtMzA=&lt;/auth&gt;</pre>

            <p>サーバーは受け取ったデータを検証します。認証が成功した場合は、次のように<b>success</b>を返します。失敗した場合はfailureを返しますが、ここではその例を省略します。</p>
            <span class="label label-success">server to client</span>
            <pre>&lt;success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/&gt;</pre>

            <p>クライアントは<b>success</b>を受け取って認証が完了したことを確認すると、上で説明したTLS完了時の処理と同様に<b>stream</b>をリフレッシュします。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream to="xmpp.example.org" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;</pre>

            <p>サーバーは、今度は<b>bind</b>と<b>session</b>を<b>features</b>に含めて返します。</p>
            <span class="label label-success">server to client</span>
            <pre>&lt;?xml version="1.0"?&gt;
&lt;stream:stream from="xmpp.example.org" id="9f8ee5" version="1.0" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"&gt;
  &lt;stream:features&gt;
    &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/&gt;
    &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/&gt;
  &lt;/stream:features&gt;</pre>

            <p><b>bind</b>、<b>session</b>については、それぞれ、次に続く<a href="#resource">リソースのバインディング</a>、<a href="#session">セッションの確立</a>で解説します。</p>

            <div class="alert alert-block alert-error">
              <h4 class="alert-heading">認証メカニズムの安全性</h4>
              <p>例えばiChatを利用したときに、TLSを利用しない状態で、あるいはTLSを利用したとしても自己署名の証明書を利用したような場合に、SASLのメカニズムに<b>PLAIN</b>を選択すると、警告ウィンドウが出ます。</p>
              <p><b>PLAIN</b>メカニズムでは、ユーザー名とパスワードをつなげたものをBase64エンコードしただけのものを送信するだけなので、平文、あるいはいい加減な証明書を使ったTLS接続上で流すのは危険だ、ということなのでしょう。</p>

              <p><b>DIGEST-MD5</b>や<b>CRAM-MD5</b>のようなメカニズムを選択した場合は、TLSではない接続の上でも警告は出ません。</p>

              <p>DIGEST-MD5やCRAM-MD5では、パスワードを含めた文字列を最終的にハッシュ化してから送信するので、送信経路で見られても安全だ、という判断なのでしょう。</p>

              <p>ということで、PLAINよりもDIGEST-MD5やCRAM-MD5のほうが安全で推奨されているかというと、それも間違いです。</p>

              <p>実際にはいくつかの問題があります。</p>

              <p>まず、このようにパスワードをハッシュ化して送信するタイプの認証方式を利用する場合、クライアントが送信してきたデータを検証するために、サーバー側も同じようにパスワードをハッシュ化して比較しなしなければならないのです。つまり、ユーザーの<b>生パスワード</b>をデータベースのどこかに保存しておかなければなりません。これは、現在のサービス運営において、やってはいけないことの一つとなっています。</p>

              <p>あるいは、DIGEST-MD5などと全く同じ方式であらかじめハッシュ化したものをデータベースに保存しておく、という方法も考えられますが、ハッシュ化の方式を外部から推測できてしまうのも問題です。またMD5の強度も現在では問題になります。</p>

              <p>ハッシュ系のメカニズムが安全だというのは、あくまで通信経路に限った話であって、生でパスワードを保存しているようなサービスにアカウントを預けていることがそもそも安全とは言えません。</p>

              <p>ここで話をPLAINに戻します。上でPLAINの危険性に注意しましたが、それはあくまで通信経路が暗号化されてなかった場合の話です。適切にTLSを利用すればその問題はなくなります。</p>

              <p>なので、サービスとしてきちんとしたものを提供するならば、サーバーは自己署名ではない証明書を準備して、設定ファイルでTLSを有効にして、メカニズムは<b>PLAIN</b>か<b>X-OAUTH2</b>のどちらか、あるいは両方を許可するのがよいでしょう。</p>

            </div>

            <div class="alert alert-block">
              <p>新しいRFCである<a href="http://xmpp.org/rfcs/rfc6120.html">RFC6120</a>では、DIGEST系の認証の代わりに<b>SCRAM</b>という仕組みが推奨されるようになりました。<b>SCRAM-SHA-1</b>や<b>SCRAM-SHA-1-PLUS</b>というのがそのためのSASLメカニズムになります。くわしくは<a href="http://tools.ietf.org/html/rfc5802">RFC5802 Salted Challenge Response Authentication Mechanism ( SCRAM ) SASL and GSS-API Mechanisms</a>を参照するとよいでしょう。</p>
              <p>ただし、ほとんどのXMPPサーバー、クライアントでは対応がまだ進んでいない状況です。</p>
            </div>

          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="resource">リソースのバインディング</h2>
            <p>認証までが完了すると、ストリームは次に、リソースと紐付けられなくてはなりません。</p>
            <p>この段階でリソースを発行し、コネクションとJIDを紐づけることになります。JIDやリソースについては前章での解説を参照して下さい。<a href="protocolbackground.html#jid">クライアント/サーバー間のやりとり[ JID - 宛先の特定 ]</a></p>
            <p>基本的には次のような手順になります。</p>
            <ol>
              <li>クライアントがサーバーにリソースの紐付けを要求</li> 
              <li>サーバーはリソースを確保し、データベースに記録後、クライアントにフルJIDを返す</li> 
            </ol>
            <p>仕様上は、1のステップで、クライアントはリソース紐付け要求を出すと同時に、希望するリソースを指定することができるようになっています。前章の例で出した<b>home</b>とか<b>work</b>みたいなものですね。ただし、これも前章で説明の通り、現状セマンティックリソースにはあまり意味はありません。</p>

            <div class="alert alert-block alert-info">
              <p>ですので、Oceanでは、1のステップでクライアントが候補として提出したリソースは無視し、2のステップで、サーバーが強制的に新たなリソースを生成してしまう方式にしています。</p>
              <p>この方式にはいくつかメリットがあるのでそうしています。一つは、無駄なコンフリクトから発生するサーバーとクライアント間のラウンドトリップの削減です。他にもクラスターの構築やHTTPバインディングを行うときに利点があるのですが、ここでは解説を省略しておきます。</p>
            </div>

            <p>それでは、実際のデータのやり取りを見てみましょう</p>

            <p>クライアントはサーバーに<b>bind</b>リクエストを送信します。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;iq id='tn281v37' type='set'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/&gt;
&lt;/iq&gt;</pre>

            <p>次のように使いたいリソースを希望することも出来ます。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;iq id='tn281v37' type='set'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;resource&gt;balcony&lt;/resource&gt;
  &lt;/bind&gt;
&lt;/iq&gt;</pre>


            <p>サーバーは<b>bind</b>リクエストを受け取ると、適切にリソースを生成し、このストリームと紐づけてデータベースなどに記録したのち、割り当てられたJIDを返します。クライアントからリソースの指定があった場合に、それを使うか、あるいは希望を無視して、サーバー側で生成したものを強制的に割り当ててしまうかはサーバー側の実装次第です。</p>
            <div class="alert alert-block alert-info">
              <p>上述の通り、Oceanでは後者を採用しています。</p>
            </div>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq id='tn281v37' type='result'&gt;
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'&gt;
    &lt;jid&gt;juliet@xmpp.example.com/4db06f06-1ea4-11dc-aca3-000bcd821bfb&lt;/jid&gt;
  &lt;/bind&gt;
&lt;/iq&gt;</pre>

          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="session">セッションの確立</h2>
            <p>次にセッションの確立を行うのですが、実はこれは空の<b>session</b> IQスタンザをクライアントがサーバーに送り、サーバーも空のスタンザで返すだけで他には何もしません。歴史的経緯で、仕様上の後方互換のためだけにこの処理が残っています。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;iq to='xmpp.example.com' type='set' id='sess_1'&gt;
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/&gt;
&lt;/iq&gt;</pre>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq from='xmpp.example.com' type='result' id='sess_1'/&gt;</pre>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="roster">ロスターの要求</h2>
            <p>ここまで来たら後少しです。クライアントはサーバーに対して、この段階で、ロスターの要求をすることになっています。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;iq id='hu2bac18' type='get'&gt;
  &lt;query xmlns='jabber:iq:roster'/&gt;
&lt;/iq&gt;</pre>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq id='hu2bac18' to='juliet@example.com/balcony' type='result'&gt;
  &lt;query xmlns='jabber:iq:roster'&gt;
    &lt;item jid='romeo@example.net' name='Romeo' subscription='both'&gt;&lt;group&gt;Friends&lt;/group&gt;&lt;/item&gt;
    &lt;item jid='mercutio@example.com' name='Mercutio' subscription='from'/&gt;
    &lt;item jid='benvolio@example.net' name='Benvolio' subscription='both'/&gt;
  &lt;/query&gt;
&lt;/iq&gt;</pre>
            <h3 id="rosterver">ロスターのバージョニング</h3>
            <p>さて、毎回ログインの度にロスターを要求することになると、登録された友人が多い場合は、通信の転送量が馬鹿になりません。1000人友人がいるような場合は毎回ログイン時に1000個のロスターアイテムを要求することになってしまいます。</p>
            <p>そこでRFC6121より、ロスターのバージョニング仕様が導入されました</p>
            <div class="alert alert-block">
              <p>ただし、RFC6121が登場したのは2011年3月なので、かなり最近の話です。<br/>ほとんどのアプリケーション、ライブラリではまだ利用されていません。</p>
            </div>

            <p>サーバーがクライアントからのロスター要求に答えて、リストを返すところをもう一度みてみましょう。<br />
            バージョニングをサポートする場合は、<b>query</b>要素に<b>ver</b>属性を付けてバージョン番号を入れておくように変更します。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq id='hu2bac18' to='juliet@example.com/balcony' type='result'&gt;
  &lt;query xmlns='jabber:iq:roster' ver='ver11'&gt;
    &lt;item jid='romeo@example.net' name='Romeo' subscription='both'&gt;&lt;group&gt;Friends&lt;/group&gt;&lt;/item&gt;
    &lt;item jid='mercutio@example.com' name='Mercutio' subscription='from'/&gt;
    &lt;item jid='benvolio@example.net' name='Benvolio' subscription='both'/&gt;
  &lt;/query&gt;
</iq></pre>

            <p>クライアントはこのようなバージョン番号付きのリストを受け取ると、ロスターの内容をローカルのデータベースにキャッシュしておき、バージョン番号も記録しておきます。</p>

            <p>次回以降、クライアントはロスター要求を行う場合、次のようにバージョン番号を加えます。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;iq from='juliet@xmpp.example.com/balcony' id='hu2bac18' type='get'&gt;
    &lt;query xmlns='jabber:iq:roster' ver='ver11'/&gt;
&lt;/iq&gt;</pre>

            <p>サーバーは、バージョン番号を確認します。指定されたバージョン番号が最新のものである場合は、次のように空の結果を返すとよいでしょう。</p>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq from='juliet@xmpp.example.net' id='hu2bac18' to='juliet@xmpp.example.net/home' type='result'/&gt;</pre>
            <p>これで無駄なデータベースアクセスやペイロードが削減できました。</p>

            <p>では指定されたバージョン以降、友人が追加、削除されるなどの変更があった場合はどうすればよいでしょうか。<br />
            サーバーは二つのパターンのうちのどちらかを採用することになっています。</p>

            <ol>
              <li>最新バージョンの値を含めた上で、全てのロスターアイテムを含めて返す。</li> 
              <li>まず空の結果を返し、アップデート分はロスタープッシュとして後で順番に渡していく。</li> 
            </ol>

            <h3 id="vcard">vCardリクエスト</h3>
            <p>名簿にリストアップされたそれぞれのユーザーの詳細な情報を取るために、あわせてvCardのリクエストのリクエストを行うのが定番の処理になっていて、ほとんどのクライアントがそうしています。vCardに関しては<a href="xep.html">拡張</a>の章で別途解説します。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="initialpresence">イニシャルプレゼンス</h2>
            <p>ログイン処理の最後の手続きとして、クライアントはサーバーに対し、プレゼンスを送信することになっています。<br />
            中身は空のシンプルなプレゼンスです。</p>
            <span class="label label-info">client to server</span>
            <pre> &lt;presence/&gt; </pre>
            <p>このプレゼンスを<b>イニシャルプレゼンス</b>と呼び、サーバーはこれを受けると次のように処理します。</p>

            <p>このユーザーがログインした事を、このユーザーをフォローしている友人の、全てのオンラインのストリームに対して通知する。</p>
            <p>このユーザーがフォローしている友人の、全てのオンラインのストリームに関するプレゼンス情報を、このユーザーに対して通知する。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="available">有効状態</h2>
            <p>ここまでの手続きで、認証も済み、セッションIDにあたりリソースを発行してフルJIDを取得しました。友人の名簿も手元にあり、誰がオンラインかが分かっています。また、友人の側も、自分がオンラインになったことが分かっています。</p>
            <p>あとはオンラインの友人に対してメッセージを送信し、コミュニケーションを開始するだけです。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="unavailable">ログアウト</h2>
            <p>ログアウトするときには、クライアントは、<b>無効プレゼンス</b>をサーバーに送信してから、ストリームを閉じて、TCPコネクションを切断します。</p>
            <span class="label label-info">client to server</span>
            <pre>&lt;presence type="unavailable"/&gt;&lt;/stream&gt;</pre>
            <p>サーバーはこれを受け取ると、このユーザーをフォローしている友人の、全てのオンラインストリームに対して、このユーザーがログアウトしたことを通知します。</p>
            <p>さらに、場合によっては、サーバーはここで様々な後始末をしなければならないかもしれません。例えば、サーバーがグループチャット機能をサポートしていた場合、このユーザーが参加していた部屋からの退出処理を済ませていなかったとしたら、この段階で自動的に退出処理も行わなければならないわけです。</p>

            <p>また、ユーザーがお行儀よく<b>無効プレゼンス</b>を送信せずに切断してしまった場合は、サーバーが自動的にフォロワーに対する通知をを始めとする後始末を行ってあげなければなりません。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2 id="timeout">タイムアウト</h2>
            <p>XMPPサービスを利用する場合、基本的にストリームはつなぎっぱなしにしておきます。<br />
            ストリームをつないでいる間ずっとチャットし続けるわけではなく、オンライン状態にしたまま放置している時間の方がむしろ長い、というケースも多いでしょう。</p>
            <p>ただし、何も送信しない状態がずっと続くことを許可してしまうと、切断検知がしにくくなりコネクションの管理に支障をきたします。ですので、こういったサービスでは定期的な<b>ping</b>の送信が行われるのが一般的です。<br/>サーバー側は受信バッファに対するデータ受信が一定期間ない場合、そのコネクションを切断するようにします。</p>

            <p>XMPPでは<a href="http://xmpp.org/extensions/xep-0199.html">Ping拡張仕様</a>がありますのでそれを利用すると良いでしょう。<br/>
            次のように中身のないスタンザのやりとりを定期的に行うことで、接続を失ってないことを確認しあいます。</p>

            <span class="label label-info">client to server</span>
            <pre>&lt;iq from='juliet@xmpp.example.org' to='xmpp.example.org' id='s2c1' type='get'&gt;
  &lt;ping xmlns='urn:xmpp:ping'/&gt;
&lt;/iq&gt;</pre>

            <span class="label label-success">server to client</span>
            <pre>&lt;iq from='xmpp.example.org' to='juliet@xmpp.example.org' id='s2c1' type='result'/&gt;</pre>

            <div class="alert alert-block alert-info">
              <p>このようなpingスタンザの代わりに、単純に改行コード<b>\r\n</b>などを飛ばしてくるクライアントもよく存在します。</p>
            </div>

            <div class="alert alert-block">
              <h4 class="alert-heading">カーネルチューニング</h4>
              <p>上記の例はあくまでアプリケーションレイヤーで切断検知を補助する仕組みです。今後は、スマートフォンの普及により、安定しないインターネット接続環境でのサービスの利用が増えることが考えられ、より細かい制御が要求されるシーンが増えるであろうことが予想されます。
              <b>sysctl</b>などを利用して以下のようなLinuxのカーネルパラメータを変更することも検討してみるとよいでしょう。</p>
              <ul>
                <li>net.ipv4.tcp_syn_retries</li> 
                <li>net.ipv4.tcp_synack_retries</li>
                <li>net.ipv4.tcp_retries2</li>
                <li>net.ipv4.tcp_orphan_retries</li>
                <li>net.ipv4.tcp_tw_recycle</li>
                <li>net.ipv4.tcp_fin_timeout</li>
              </ul>
            </div>

          </div><!--/span-->
        </div><!--/row-->

      </div><!--/span-->
    </div><!--/row-->

    <hr />
    <footer>
      <p>&copy; Lyo Kato 2012</p>
    </footer>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>

</body>
</html>
